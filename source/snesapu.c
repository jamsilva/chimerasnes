#include "apu.h"
#include "chisnes.h"
#include "memmap.h"
#include "snesapu.h"
#include "soundux.h"

typedef struct
{
	/* Waveform */
	uint8_t  bHdr;      /* Block Header for current block */
	uint8_t  mFlg;      /* Mixing flags (see MixF) */
	uint16_t bCur;      /* -> current block */
	uint16_t bMixStart; /* -> start block */
	uint16_t bStart;    /* -> start block */

	/* Envelope */
	int32_t  eAdj;  /* Amount to adjust envelope height */
	int32_t  eDest; /* Envelope Destination */
	int32_t  eVal;  /* Current envelope value */
	uint32_t eDec;  /* Pitch Decimal (.16) */
	uint32_t eRate; /* Rate of envelope adjustment (16.16) */
	uint8_t  eMode; /* [3-0] Current mode (see EnvM) ; [6-4] ADSR mode to switch into from Gain ; [7] Envelope is idle */
	uint8_t  eRIdx; /* Index in RateTab (0-31) */

	int8_t   _VoiceMix_PAD1 : 8;

	/* Samples */
	int8_t  sIdx;     /* -> current sample in sBuf */
	int32_t sP1;      /* Last sample decompressed (prev1) */
	int32_t sP2;      /* Second to last sample (prev2) */
	int16_t sBuf[32]; /* 32 + 32 bytes for decompressed sample blocks */

	/* Mixing */
	int32_t  mChnL;    /* Channel Volume (-24.7) */
	int32_t  mChnR;    /* Channel Volume (-24.7) */
	int32_t  mOut;     /* Last sample output before chn vol (used forpitch mod) */
	uint32_t mDec;     /* Pitch Decimal (.16) (used as delta forinterpolation) */
	uint32_t mOrgP;    /* Original pitch rate converted from the DSP (16.16) */
	uint32_t mOrgRate; /* Pitch Rate before modulation (16.16) */
	uint32_t mRate;    /* Pitch Rate after modulation (16.16) */
} VoiceMix;

static const struct
{
	uint8_t m;
	int32_t o;
} chs[8] =
{
	{0x01, 0x00}, {0x02, 0x10}, {0x04, 0x20}, {0x08, 0x30},
	{0x10, 0x40}, {0x20, 0x50}, {0x40, 0x60}, {0x80, 0x70}
};

/* Envelope mode masks */
#define E_TYPE 0x01 /* Type of adj: Constant(1/64 or 1/256) / Exp.(255/256) */
#define E_DIR  0x02 /* Direction: Decrease / Increase */
#define E_DEST 0x04 /* Destination: Default(0 or 1) / Other(x/8 or .75) */
#define E_ADSR 0x08 /* Envelope mode: Gain/ADSR */
#define E_IDLE 0x80 /* Envelope speed is set to 0 */

#define E_DEC    0x00 /* Linear decrease */
#define E_EXP    0x01 /* Exponential decrease */
#define E_INC    0x02 /* Linear increase */
#define E_BENT   0x06 /* Bent line increase */
#define E_REL    0x08 /* Release mode */
#define E_SUST   0x09 /* Sustain mode */
#define E_ATT    0x0A /* Attack mode */
#define E_DECAY  0x0D /* Decay mode */
#define E_DIRECT 0x87 /* Direct gain */

/* Envelope adjustment rates */
#define A_GAIN  (1 << E_SHIFT)         /* Amount to adjust envelope values */
#define A_LIN   ((128 * A_GAIN) / 64)  /* Linear rate to increase/decrease envelope */
#define A_KOF   ((128 * A_GAIN) / 256) /* Rate to decrease envelope during release */
#define A_BENT  ((128 * A_GAIN) / 256) /* Rate to increase envelope after bend */
#define A_NOATT (64 * A_GAIN)          /* Rate to increase if attack rate is set to 0ms */
#define A_EXP   0                      /* Rate to decrease envelope exponentially (Not used) */

/* Envelope destination values */
#define D_MAX    ((128 * A_GAIN) - 1)     /* Maximum envelope value */
#define D_ATTACK ((128 * A_GAIN) - 1)     /* Destination of attack rate */
#define D_BENT   ((128 * A_GAIN * 3) / 4) /* First destination of bent line */
#define D_EXP    ((128 * A_GAIN) / 8)     /* Minimum decay destination value */
#define D_MIN    0                        /* Minimum envelope value */

#define DSP_SIZE 2

static int32_t brrTab[256];
static int16_t gaussTab[1024];

static const int16_t gaussPre[512] = /* 12-bit Gaussian curve generated by SNES DSP */
{
	0,     0,     0,     0,     0,     0,     0,     0,
	0,     0,     0,     0,     0,     0,     0,     0,
	16,    16,    16,    16,    16,    16,    16,    16,
	16,    16,    16,    32,    32,    32,    32,    32,
	32,    32,    48,    48,    48,    48,    48,    64,
	64,    64,    64,    64,    80,    80,    80,    80,
	96,    96,    96,    96,    112,   112,   112,   128,
	128,   128,   144,   144,   144,   160,   160,   160,
	176,   176,   176,   192,   192,   208,   208,   224,
	224,   240,   240,   240,   256,   256,   272,   272,
	288,   304,   304,   320,   320,   336,   336,   352,
	368,   368,   384,   384,   400,   416,   432,   432,
	448,   464,   464,   480,   496,   512,   512,   528,
	544,   560,   576,   576,   592,   608,   624,   640,
	656,   672,   688,   704,   720,   736,   752,   768,
	784,   800,   816,   832,   848,   864,   880,   896,
	928,   944,   960,   976,   992,   1024,  1040,  1056,
	1072,  1104,  1120,  1136,  1168,  1184,  1216,  1232,
	1248,  1280,  1296,  1328,  1344,  1376,  1392,  1424,
	1440,  1472,  1504,  1520,  1552,  1584,  1600,  1632,
	1664,  1696,  1712,  1744,  1776,  1808,  1840,  1872,
	1888,  1920,  1952,  1984,  2016,  2048,  2080,  2112,
	2144,  2192,  2224,  2256,  2288,  2320,  2352,  2400,
	2432,  2464,  2496,  2544,  2576,  2608,  2656,  2688,
	2736,  2768,  2800,  2848,  2880,  2928,  2976,  3008,
	3056,  3088,  3136,  3184,  3216,  3264,  3312,  3360,
	3392,  3440,  3488,  3536,  3584,  3632,  3680,  3728,
	3776,  3824,  3872,  3920,  3968,  4016,  4064,  4112,
	4160,  4208,  4272,  4320,  4368,  4416,  4480,  4528,
	4576,  4640,  4688,  4752,  4800,  4864,  4912,  4976,
	5024,  5088,  5136,  5200,  5248,  5312,  5376,  5424,
	5488,  5552,  5616,  5664,  5728,  5792,  5856,  5920,
	5984,  6048,  6096,  6160,  6224,  6288,  6352,  6416,
	6480,  6560,  6624,  6688,  6752,  6816,  6880,  6944,
	7024,  7088,  7152,  7216,  7296,  7360,  7424,  7504,
	7568,  7632,  7712,  7776,  7856,  7920,  7984,  8064,
	8128,  8208,  8272,  8352,  8432,  8496,  8576,  8640,
	8720,  8800,  8864,  8944,  9008,  9088,  9168,  9232,
	9312,  9392,  9472,  9536,  9616,  9696,  9776,  9840,
	9920,  10000, 10080, 10160, 10240, 10304, 10384, 10464,
	10544, 10624, 10704, 10784, 10848, 10928, 11008, 11088,
	11168, 11248, 11328, 11408, 11488, 11568, 11648, 11712,
	11792, 11872, 11952, 12032, 12112, 12192, 12272, 12352,
	12432, 12512, 12592, 12672, 12752, 12832, 12896, 12976,
	13056, 13136, 13216, 13296, 13376, 13456, 13536, 13616,
	13680, 13760, 13840, 13920, 14000, 14080, 14144, 14224,
	14304, 14384, 14464, 14528, 14608, 14688, 14768, 14832,
	14912, 14992, 15056, 15136, 15216, 15280, 15360, 15440,
	15504, 15584, 15648, 15728, 15808, 15872, 15952, 16016,
	16080, 16160, 16224, 16304, 16368, 16432, 16512, 16576,
	16640, 16720, 16784, 16848, 16912, 16976, 17056, 17120,
	17184, 17248, 17312, 17376, 17440, 17504, 17568, 17632,
	17696, 17744, 17808, 17872, 17936, 18000, 18048, 18112,
	18176, 18224, 18288, 18336, 18400, 18448, 18512, 18560,
	18624, 18672, 18720, 18784, 18832, 18880, 18928, 18976,
	19040, 19088, 19136, 19184, 19232, 19280, 19312, 19360,
	19408, 19456, 19504, 19536, 19584, 19632, 19664, 19712,
	19744, 19792, 19824, 19856, 19904, 19936, 19968, 20016,
	20048, 20080, 20112, 20144, 20176, 20208, 20240, 20272,
	20304, 20320, 20352, 20384, 20400, 20432, 20464, 20480,
	20512, 20528, 20544, 20576, 20592, 20608, 20640, 20656,
	20672, 20688, 20704, 20720, 20736, 20752, 20752, 20768,
	20784, 20800, 20800, 20816, 20832, 20832, 20848, 20848,
	20848, 20864, 20864, 20864, 20864, 20864, 20880, 20880
};

/* Register write handler prototypes */
static void RADSR1(int32_t, uint8_t);
static void RADSR2(int32_t, uint8_t);
static void REDl(int32_t, uint8_t);
static void REFB(int32_t, uint8_t);
static void REVolL(int32_t, uint8_t);
static void REVolR(int32_t, uint8_t);
static void RFCI(int32_t, uint8_t);
static void RFlg(int32_t, uint8_t);
static void RESA(int32_t, uint8_t);
static void RGain(int32_t, uint8_t);
static void RKOn(int32_t, uint8_t);
static void RKOf(int32_t, uint8_t);
static void RMVolL(int32_t, uint8_t);
static void RMVolR(int32_t, uint8_t);
static void RNull(int32_t, uint8_t);
static void RPitch(int32_t, uint8_t);
static void RVolL(int32_t, uint8_t);
static void RVolR(int32_t, uint8_t);
static void REndX(int32_t, uint8_t);

static void (*dspRegs[0x80])(int32_t, uint8_t) = /* Jump table for DSP register writes (see DSPIn) */
{
	RVolL, RVolR, RPitch, RPitch, RNull,  RADSR1, RADSR2, RGain,
	RNull, RNull, RNull,  RNull,  RMVolL, REFB,   RNull,  RFCI,
	RVolL, RVolR, RPitch, RPitch, RNull,  RADSR1, RADSR2, RGain,
	RNull, RNull, RNull,  RNull,  RMVolR, RNull,  RNull,  RFCI,
	RVolL, RVolR, RPitch, RPitch, RNull,  RADSR1, RADSR2, RGain,
	RNull, RNull, RNull,  RNull,  REVolL, RNull,  RNull,  RFCI,
	RVolL, RVolR, RPitch, RPitch, RNull,  RADSR1, RADSR2, RGain,
	RNull, RNull, RNull,  RNull,  REVolR, RNull,  RNull,  RFCI,
	RVolL, RVolR, RPitch, RPitch, RNull,  RADSR1, RADSR2, RGain,
	RNull, RNull, RNull,  RNull,  RKOn,   RNull,  RNull,  RFCI,
	RVolL, RVolR, RPitch, RPitch, RNull,  RADSR1, RADSR2, RGain,
	RNull, RNull, RNull,  RNull,  RKOf,   RNull,  RNull,  RFCI,
	RVolL, RVolR, RPitch, RPitch, RNull,  RADSR1, RADSR2, RGain,
	RNull, RNull, RNull,  RNull,  RFlg,   RESA,   RNull,  RFCI,
	RVolL, RVolR, RPitch, RPitch, RNull,  RADSR1, RADSR2, RGain,
	RNull, RNull, RNull,  RNull,  REndX,  REDl,   RNull,  RFCI
};

static const uint32_t freqTab[32] = /* Frequency table; number of samples between updates. Used to determine envelope rates and noise frequencies */
{
	0,   2048, 1536, 1280, 1024, 768, 640, 512,
	384, 320,  256,  192,  160,  128, 96,  80,
	64,  48,   40,   32,   24,   20,  16,  12,
	10,  8,    6,    5,    4,    3,   2,   1
};

static const uint64_t max48 = UINT64_C(0xffffffffffff);

static uint8_t src_buffer[9]; /* Temporary */

/* Mixing */
static VoiceMix mix[8];      /* Mixing settings for each voice and waveform playback */
static uint8_t  voiceKon;    /* Voices that are currently being key on */
static uint32_t rateTab[32]; /* Update Rate Table */

/* DSP Options */
static int32_t  dspRate;  /* Output sample rate */
static uint32_t pitchAdj; /* Amount to adjust pitch rates [16.16] */

/* Prototypes for functions that will go in dspDecmp */
static INLINE void UnpckSrc(uint8_t blk_hdr, uint16_t* xsample_blk, int16_t* output_buf, int32_t* smp_1, int32_t* smp_2);

/* Volume */
static int32_t volAdj;   /* Amount to adjust main volumes [-15. 16] */
static int32_t volMainL; /* Main volume */
static int32_t volMainR;
static int32_t volEchoL; /* Echo volume */
static int32_t volEchoR;

/* Echo */
static uint32_t echoStart; /* Echo Start Address */
static uint32_t echoDel;   /* Size of delay (in bytes) */
static uint32_t echoCur;   /* Current sample in echo area */
static int32_t  echoFB;    /* Echo feedback */

/* Noise */
static int32_t nSmp;  /* Current Noise sample */
static int16_t nDec;  /* Noise accumulator [.32] (>= 1 generate a new sample) */
static int16_t nRate; /* Noise sample rate reciprocal [.32] */

/* Echo filtering */
static uint8_t firCur;  /* Index of the first sample to feed into the filter */
static uint8_t disEcho; /* 0 if echo is enabled */

/* Storage buffers */
extern int16_t Loop[FIRBUF];
extern int8_t  FilterTaps[8];

/* Other */
static Channel channels[NUM_CHANNELS];

static INLINE void APUTimerPulse()
{
	int32_t i;
	EXT.t64Cnt = (EXT.t64Cnt + 1) & 7;

	if (EXT.t64Cnt == 7)
		i = 0;
	else
		i = 2;

	for (; i < 3; ++i)
	{
		if (APU.TimerEnabled[i])
		{
			APU.Timer[i]++;

			if (APU.Timer[i] < APU.TimerTarget[i])
				continue;

			int32_t pos = 0xfd + i;
			IAPU.RAM[pos] = (IAPU.RAM[pos] + 1) & 0xf;
			APU.Timer[i] -= APU.TimerTarget[i];
			IAPU.WaitCounter = 1;
			IAPU.Executing = Settings.APUEnabled;
		}
	}
}

void APUMainLoop()
{
	while (CPU.Cycles < EXT.NextAPUTimerPos)
	{
		APU_EXECUTE();
		APUTimerPulse();
		EXT.APUTimerCounter_err += EXT.APUTimerCounter;
		EXT.NextAPUTimerPos += (EXT.APUTimerCounter_err >> FIXED_POINT_SHIFT);
		EXT.APUTimerCounter_err &= FIXED_POINT_REMAINDER;
	}
}

static INLINE uint8_t DSP_GET_BYTE(uint16_t addr)
{
	return IAPU.RAM[addr];
}

static INLINE uint16_t DSP_GET_WORD(uint16_t addr)
{
	return READ_WORD(&IAPU.RAM[addr]);
}

static INLINE void DSP_SET_BYTE(uint16_t addr, uint8_t data)
{
	IAPU.RAM[addr] = data;
}

static INLINE void DSP_SET_WORD(uint16_t addr, uint16_t data)
{
	WRITE_WORD(&IAPU.RAM[addr], data);
}

static INLINE uint16_t DSP_GET_SRC(int32_t i)
{
	return DSP_GET_WORD((APU.DSP[APU_DIR] << 8) + (APU.DSP[chs[i].o + APU_SRCN] << 2));
}

static INLINE uint16_t DSP_GET_SRC_LOOP(int32_t i)
{
	return DSP_GET_WORD((APU.DSP[APU_DIR] << 8) + (APU.DSP[chs[i].o + APU_SRCN] << 2) + 2);
}

static INLINE uint8_t* DSP_GET_SRC_P(uint16_t addr)
{
	int32_t len;

	if (addr <= (0x10000 - 9))
		return &IAPU.RAM[addr];

	len = 0x10000 - addr;
	memcpy(src_buffer, &IAPU.RAM[addr], (size_t) len);
	memcpy(src_buffer + len, IAPU.RAM, (size_t) (9 - len));
	return src_buffer;
}

static INLINE uint16_t DSP_GET_PITCH(int32_t i)
{
	return ((APU.DSP[chs[i].o + APU_P_HIGH] << 8) | APU.DSP[chs[i].o + APU_P_LOW]) & FREQUENCY_MASK;
}

/* Start Waveform Decompression
   Called when a voice is keyed on to set up the internal data for waveform
   mixing, and decompress the first block. */
static INLINE void StartSrc(int32_t ch)
{
	/* Initialize interpolation */
	memset(&mix[ch].sBuf[0x10], 0, sizeof(int16_t) * 16);
	mix[ch].bCur = mix[ch].bStart;
	mix[ch].bMixStart = mix[ch].bCur;
	mix[ch].bHdr = DSP_GET_BYTE(mix[ch].bCur);
	mix[ch].sIdx = -9;
	mix[ch].sP1 = 0;
	mix[ch].sP2 = 0;

	/* Start voice */
	APU.DSP[APU_ENDX] &= ~chs[ch].m;
	UnpckSrc(mix[ch].bHdr, &mix[ch].bCur, mix[ch].sBuf, &mix[ch].sP1, &mix[ch].sP2);
}

static INLINE void ChgSilence(int32_t ch);

static INLINE void UpdateSrc(int32_t ch)
{
	if (mix[ch].bHdr & 1) /* Is this the end block? */
	{
		APU.DSP[APU_ENDX] |= chs[ch].m;

		if (!(mix[ch].bHdr & 2)) /* Loop? */
		{
			mix[ch].mFlg |= MFLG_END;
			memset(&mix[ch].sBuf[mix[ch].sIdx & 0x10], 0, sizeof(int16_t) * 16);
			mix[ch].eVal = D_MIN;
			return;
		}
		else
			mix[ch].bCur = DSP_GET_SRC_LOOP(ch);
	}

	/* Save block header */
	mix[ch].bHdr = DSP_GET_BYTE(mix[ch].bCur);

	if((mix[ch].bHdr & 1) && !(mix[ch].bHdr & 2)) /* Is this the end block? */
	{
		APU.DSP[APU_ENDX] |= chs[ch].m;
		mix[ch].mFlg |= MFLG_END;
		ChgSilence(ch);
	}

	if (mix[ch].mFlg & MFLG_OFF)
		mix[ch].bCur += 9;
	else
		UnpckSrc(mix[ch].bHdr, &mix[ch].bCur, &mix[ch].sBuf[mix[ch].sIdx & 0x10], &mix[ch].sP1, &mix[ch].sP2);
}

static INLINE void SetNoiseHertz()
{
	uint8_t i = APU.DSP[APU_FLG] & 0x1f;

	if(i == 0)
	{
		nRate = 0;
		nSmp = 0;
	}
	else
		nRate =  (uint32_t) (max48 / (uint64_t)(freqTab[i] << 16));
}

static INLINE void InitReg(int32_t reg, uint8_t val)
{
	int32_t i = (reg & 0x70) >> 4;
	APU.DSP[reg] = val;

	if (!((~reg) & MFLG_OFF & mix[i].mFlg))
		(*dspRegs[reg])(i, val);
}

void InitAPUDSP()
{
	int32_t i, c;

	/* Reset values so SetDSPOpt will create new ones */
	dspRate = -1;
	disEcho = 0;

	for (i = 0; i < 8; i++) /* Erase all mixer settings */
		memset(&mix[i], 0, sizeof(VoiceMix));

	for (i = 0; i < 8; i++) /* Set pointers to reasonable default values. Otherwise savestates cause SEGVs! */
	{
		mix[i].sIdx = 0;
		mix[i].bStart = DSP_GET_SRC(i);
		mix[i].bMixStart = mix[i].bStart;
		mix[i].bCur = DSP_GET_SRC(i);
	}

	for (i = 0; i < 13; i++) /* Build a look-up table for all possible expanded values in a BRR block. Range 0-12 */
		for (c = 0; c < 16; c++)
			brrTab[(i << 4) + c] = (int32_t) ((int16_t) (c << 12) >> 12) << i >> 1;

	for (i = 13; i < 16; i++) /* Range 13-15 */
		for (c = 0; c < 16; c++)
			brrTab[(i << 4) + c] = (int32_t) ((int16_t) (c << 12) >> 12) & ~0x7ff;

	for (i = 0; i < 256; i++) /* Interleave Gaussian table */
	{
		gaussTab[(i << 2) + 3] = gaussPre[i + 0];
		gaussTab[(i << 2) + 2] = gaussPre[i + 256];
		gaussTab[(i << 2) + 1] = gaussPre[511 - i];
		gaussTab[(i << 2) + 0] = gaussPre[255 - i];
	}
}

void SetPlaybackRate(int32_t rate)
{
	int32_t i;
	uint64_t r, rr;
	rate = (rate >= 8000 && rate <= 192000) ? rate : SNES_SAMPLE_RATE;
	disEcho = disEcho & ~DSP_NOECHO; /* Disable echo */
	SetAPUDSPAmp(FIXED_POINT); /* Save option flags */

	if (rate == dspRate) /* Is the sample rate unchanged? */
		return;

	dspRate = rate;
	pitchAdj = (uint32_t) (((uint64_t) SNES_SAMPLE_RATE << (FIXED_POINT_SHIFT + 4)) / dspRate);
	r = (uint64_t) 0x1000 * pitchAdj;
	rateTab[0] = 0;

	for (i = 1; i < 32; i++)
	{
		rr = r / freqTab[i];
		rateTab[i] = (uint32_t) ((rr >> FIXED_POINT_SHIFT) + ((rr & FIXED_POINT_REMAINDER) ? 1 : 0));
	}

	for (i = 0; i < 7; i++) /* Adjust voice rates */
	{
		mix[i].mOrgP = DSP_GET_PITCH(i);
		r = (uint64_t) mix[i].mOrgP * pitchAdj;
		mix[i].mOrgRate = (uint32_t) ((r >> FIXED_POINT_SHIFT) + ((r & FIXED_POINT_REMAINDER) ? 1 : 0));
		mix[i].mRate = mix[i].mOrgRate;
		mix[i].mDec = 0;
		mix[i].eRate = rateTab[mix[i].eRIdx];
		mix[i].eDec = 0;
	}

	/* Adjust echo delay */
	InitReg(APU_ESA, APU.DSP[APU_ESA]);
	InitReg(APU_EDL, APU.DSP[APU_EDL]);

	/* Erase sample buffer */
	memset(Loop, 0, sizeof(int16_t) * FIRBUF);
}

void ResetAPUDSP()
{
	int32_t i;

	for (i = 0; i < 8; i++) /* Voice is inactive */
	{
		mix[i].mFlg &= (MFLG_MUTE | MFLG_OFF);
		mix[i].mFlg |= MFLG_OFF;
	}

	disEcho &= DSP_NOECHO; /* Disable echo */
	disEcho |= 1; /* Disable echo if all taps are 0 */

	/* Erase DSP Registers */
	memset(APU.DSP, 0, 0x80);

	/* Place DSP in power up mode */
	APU.DSP[APU_FLG] = APU_SOFT_RESET | APU_MUTE | APU_ECHO_DISABLED;
	EXT.t64Cnt = 0;

	for (i = 0; i < 8; i++) /* Erase internal mixing settings. We'll just save-and-restore mFlg instead of selectively zeroing */
	{
		/* Set pointers to reasonable default values. Otherwise savestates cause SEGVs! */
		mix[i].bStart = DSP_GET_SRC(i);
		mix[i].bMixStart = mix[i].bStart;
		mix[i].bCur = DSP_GET_SRC(i);
		mix[i].bHdr = DSP_GET_BYTE(mix[i].bCur);

		/* Envelope */
		ChgSilence(i);
		mix[i].eDec = 0;

		/* Samples */
		memset(mix[i].sBuf, 0, sizeof(int16_t) * 32);
		mix[i].sIdx = mix[i].sP1 = mix[i].sP2 = 0;

		/* Mixing */
		mix[i].mChnL = mix[i].mChnR = 0;
		RPitch(i, APU.DSP[chs[i].o + APU_P_LOW]);
		mix[i].mDec = mix[i].mOut = 0;

		/* Channels */
		channels[i].type  = SOUND_SAMPLE;
		channels[i].envx  = 0;
	}

	/* Erase global volume settings */
	volMainL = volMainR = volEchoL = volEchoR = 0;

	/* Erase noise settings */
	nDec = nRate = 0;
	nSmp = 0x4000;

	/* Reset echo variables */
	echoStart = echoCur = echoFB = 0;
	echoDel = 2; /* Delay 1 sample */

	/* Echo filter */
	memset(Loop, 0, sizeof(int16_t) * FIRBUF); /* Erase filter memory */
	memset(FilterTaps, 0, sizeof(int8_t) * 8); /* Reset filter coefficients */

	/* Reset filter variables */
	firCur = 0;

	/* Disable voices */
	voiceKon = 0;
}

void StoreAPUDSP()
{
	int32_t i, eVal;
	SetFilterCoefficient(0, (int32_t) (int8_t) APU.DSP[APU_C0]); /* No filter */

	for (i = 0; i < 8; i++)
	{
		if (mix[i].mFlg & MFLG_OFF) /* Channel is inactive */
		{
			mix[i].eMode     = MODE_NONE;
			channels[i].mode = MODE_NONE;
		}
		else
		{
			if (mix[i].mFlg & MFLG_KOFF) /* Key off state */
				channels[i].mode = MODE_RELEASE;
			else if (APU.DSP[chs[i].o + APU_ADSR1] & 0x80) /* ADSR mode */
				channels[i].mode = MODE_ADSR;
			else if (!(APU.DSP[chs[i].o + APU_GAIN] & 0x80)) /* Direct GAIN mode */
				channels[i].mode = MODE_GAIN;
			else /* Indirect GAIN mode */
			{
				switch (APU.DSP[chs[i].o + APU_GAIN] & 0x60)
				{
					case 0x00:
						channels[i].mode = MODE_DECREASE_LINEAR;
						break;
					case 0x20:
						channels[i].mode = MODE_DECREASE_EXPONENTIAL;
						break;
					case 0x40:
						channels[i].mode = MODE_INCREASE_LINEAR;
						break;
					case 0x60:
						channels[i].mode = MODE_INCREASE_BENT_LINE;
						break;
				}
			}
		}

		channels[i].type = (APU.DSP[APU_NON] & chs[i].m) ? SOUND_NOISE : SOUND_SAMPLE;
		eVal = mix[i].eVal;

		if (eVal > D_ATTACK)
			eVal = D_ATTACK;
		else if (eVal < 0)
			eVal = 0;

		channels[i].envx = eVal >> E_SHIFT;

		if (mix[i].sIdx >= 0)
		{
			memcpy(channels[i].decoded, &mix[i].sBuf[mix[i].sIdx & 0x10], sizeof(int16_t) * 16);
			channels[i].sample_pointer = (uint32_t) (mix[i].sIdx & 0x0f);
		}
		else
		{
			memset(channels[i].decoded, 0, sizeof(int16_t) * 16);
			channels[i].sample_pointer = (uint32_t) (mix[i].sIdx & 0xff);
		}

		channels[i].block = (int16_t*) &channels[i].decoded[channels[i].sample_pointer];
		channels[i].block_pointer = (uint32_t) mix[i].bCur;

		/* Store OUTX ENVX */
		APU.DSP[chs[i].o + APU_OUTX] = (uint8_t) ((mix[i].mFlg & (MFLG_OFF | MFLG_END)) ? 0 : (mix[i].mOut >> 8));
		APU.DSP[chs[i].o + APU_ENVX] = (uint8_t) ((mix[i].mFlg & (MFLG_OFF | MFLG_END)) ? 0 : ((eVal >> E_SHIFT) & 0x7f));
	}

	IAPU.RAM[0xf3] = APU.DSP[IAPU.RAM[0xf2] & 0x7f]; /* Store 0xf3 */
}

void RestoreAPUDSP() /* Restore DSP's State of Operation */
{
	int32_t i;
	uint8_t mFlg, flg;
	voiceKon = APU.DSP[APU_KON];

	for (i = 0; i < 8; i++)
	{
		mix[i].bStart = DSP_GET_SRC(i);
		mix[i].bMixStart = mix[i].bStart;
		mix[i].bCur = (uint16_t) (channels[i].block_pointer & 0xffff);
		memset(&mix[i].sBuf[0x10], 0, sizeof(int16_t) * 16);
		memcpy(mix[i].sBuf, channels[i].decoded, sizeof(int16_t) * 16);

		if (channels[i].sample_pointer >= 247 && channels[i].sample_pointer <= 255)
			mix[i].sIdx = (int8_t) (channels[i].sample_pointer & 0xff);
		else
			mix[i].sIdx = (int8_t) (channels[i].sample_pointer & 0x0f);

		mFlg = ((mix[i].mFlg & MFLG_MUTE) | (channels[i].mode == MODE_NONE ? MFLG_OFF : 0) | (channels[i].mode == MODE_RELEASE ? MFLG_KOFF : 0));

		if (mFlg & MFLG_OFF)
			mFlg &= ~(MFLG_KOFF | MFLG_END);

		mix[i].mFlg = mFlg;
		InitReg(chs[i].o + APU_VOL_LEFT, APU.DSP[chs[i].o + APU_VOL_LEFT]);
		InitReg(chs[i].o + APU_VOL_RIGHT, APU.DSP[chs[i].o + APU_VOL_RIGHT]);
		InitReg(chs[i].o + APU_P_LOW, APU.DSP[chs[i].o + APU_P_LOW]);

		/* Default to release mode settings */
		mix[i].eRIdx = 31;
		mix[i].eRate = rateTab[mix[i].eRIdx];
		mix[i].eDec = 0;
		mix[i].eAdj = A_KOF;
		mix[i].eDest = D_MIN;
		mix[i].eVal = channels[i].envx << E_SHIFT;
		InitReg(chs[i].o + APU_ADSR1, APU.DSP[chs[i].o + APU_ADSR1]);
		mix[i].mOut = (int32_t) (int8_t) APU.DSP[chs[i].o + APU_OUTX] << 8;
		mix[i].mDec = 0;
	}

	/* Setup global paramaters */
	InitReg(APU_MVOL_LEFT, APU.DSP[APU_MVOL_LEFT]);
	InitReg(APU_MVOL_RIGHT, APU.DSP[APU_MVOL_RIGHT]);
	InitReg(APU_EVOL_LEFT, APU.DSP[APU_EVOL_LEFT]);
	InitReg(APU_EVOL_RIGHT, APU.DSP[APU_EVOL_RIGHT]);

	/* Don't "APU_SOFT_RESET" */
	flg = APU.DSP[APU_FLG];
	RFlg((APU_FLG & 0x70) >> 4, flg & ~APU_SOFT_RESET);
	APU.DSP[APU_FLG] = flg;
	InitReg(APU_ESA, APU.DSP[APU_ESA]);
	InitReg(APU_EFB, APU.DSP[APU_EFB]);
	InitReg(APU_EDL, APU.DSP[APU_EDL]);

	for (i = 0; i < 8; i++)
		InitReg(chs[i].o + APU_C0, APU.DSP[chs[i].o + APU_C0]);
}

void SetAPUDSPAmp(int32_t amp) /* DSP Pre-Amplification Level */
{
	/* Update global volumes */
	volAdj = amp;
	InitReg(APU_MVOL_LEFT, APU.DSP[APU_MVOL_LEFT]);
	InitReg(APU_MVOL_RIGHT, APU.DSP[APU_MVOL_RIGHT]);
	InitReg(APU_EVOL_LEFT, APU.DSP[APU_EVOL_LEFT]);
	InitReg(APU_EVOL_RIGHT, APU.DSP[APU_EVOL_RIGHT]);
}

static INLINE void ChgSus(int32_t i)
{
	mix[i].eRIdx = APU.DSP[chs[i].o + APU_ADSR2] & 0x1f;

	if (rateTab[mix[i].eRIdx] == 0 || mix[i].eVal <= D_MIN)
	{
		mix[i].eMode = E_IDLE | E_SUST;
		mix[i].eDec = 0;
	}
	else
		mix[i].eMode = E_SUST;

	mix[i].eRate = rateTab[mix[i].eRIdx];
	mix[i].eAdj = A_EXP;
	mix[i].eDest = D_MIN;
}

static INLINE void ChgDec(int32_t i)
{
	uint8_t sl = APU.DSP[chs[i].o + APU_ADSR2] >> 5;
	int32_t eDest = (int32_t) (sl + 1) * D_EXP;

	if (sl == 7 || mix[i].eVal <= eDest)
	{
		ChgSus(i);
		return;
	}

	mix[i].eRIdx = ((APU.DSP[chs[i].o + APU_ADSR1] & 0x70) >> 3) + 0x10;
	mix[i].eRate = rateTab[mix[i].eRIdx];
	mix[i].eAdj = A_EXP;
	mix[i].eDest = eDest;
	mix[i].eMode = E_DECAY;
}

static INLINE void ChgAtt(int32_t i)
{
	uint8_t ar = APU.DSP[chs[i].o + APU_ADSR1] & 0x0f;

	if (mix[i].eVal >= D_ATTACK)
	{
		ChgDec(i);
		return;
	}

	mix[i].eRIdx = (ar << 1) + 1;
	mix[i].eRate = rateTab[mix[i].eRIdx];
	mix[i].eAdj = (ar == 0x0f) ? A_NOATT : A_LIN;
	mix[i].eDest = D_ATTACK;
	mix[i].eMode = E_ATT;
}

static INLINE void ChgADSR(int32_t i)
{
	switch (mix[i].eMode)
	{
		case E_ATT:
			ChgAtt(i);
			break;
		case E_DECAY:
			ChgDec(i);
			break;
		case E_SUST:
		case(E_IDLE | E_SUST):
			if (mix[i].eVal > D_MIN)
				ChgSus(i);

			break;
	}
}

static INLINE void ChgGain(int32_t i)
{
	if (!(APU.DSP[chs[i].o + APU_GAIN] & 0x80)) /* Is gain direct? */
	{
		mix[i].eMode = E_DIRECT;
		mix[i].eRIdx = 0;
		mix[i].eRate = rateTab[mix[i].eRIdx];
		mix[i].eAdj = A_EXP;
		mix[i].eVal = mix[i].eDest = (int32_t) (APU.DSP[chs[i].o + APU_GAIN] & 0x7f) * A_GAIN;
		return;
	}

	switch (APU.DSP[chs[i].o + APU_GAIN] & 0x60)
	{
	case 0x00: /* GainDec */
		mix[i].eRIdx = APU.DSP[chs[i].o + APU_GAIN] & 0x1f;

		if (rateTab[mix[i].eRIdx] == 0 || mix[i].eVal <= D_MIN)
		{
			mix[i].eMode = E_IDLE | E_DEC;
			mix[i].eDec = 0;
		}
		else
			mix[i].eMode = E_DEC;

		mix[i].eRate = rateTab[mix[i].eRIdx];
		mix[i].eAdj = A_LIN;
		mix[i].eDest = D_MIN;
		break;
	case 0x20: /* GainExp */
		mix[i].eRIdx = APU.DSP[chs[i].o + APU_GAIN] & 0x1f;

		if (rateTab[mix[i].eRIdx] == 0 || mix[i].eVal <= D_MIN)
		{
			mix[i].eMode = E_IDLE | E_EXP;
			mix[i].eDec = 0;
		}
		else
			mix[i].eMode = E_EXP;

		mix[i].eRate = rateTab[mix[i].eRIdx];
		mix[i].eAdj = A_EXP;
		mix[i].eDest = D_MIN;
		break;
	case 0x40: /* GainInc */
		mix[i].eRIdx = APU.DSP[chs[i].o + APU_GAIN] & 0x1f;

		if (rateTab[mix[i].eRIdx] == 0 || mix[i].eVal >= D_ATTACK)
		{
			mix[i].eMode = E_IDLE | E_INC;
			mix[i].eDec = 0;
		}
		else
			mix[i].eMode = E_INC;

		mix[i].eRate = rateTab[mix[i].eRIdx];
		mix[i].eAdj = A_LIN;
		mix[i].eDest = D_ATTACK;
		break;
	case 0x60: /* GainBent */
		mix[i].eRIdx = APU.DSP[chs[i].o + APU_GAIN] & 0x1f;

		if (rateTab[mix[i].eRIdx] == 0 || mix[i].eVal >= D_ATTACK)
		{
			mix[i].eMode = E_IDLE | E_BENT;
			mix[i].eDec = 0;
		}
		else
			mix[i].eMode = E_BENT;

		mix[i].eRate = rateTab[mix[i].eRIdx];

		if (mix[i].eVal < D_BENT)
		{
			mix[i].eAdj = A_LIN;
			mix[i].eDest = D_BENT;
		}
		else
		{
			mix[i].eAdj = A_BENT;
			mix[i].eDest = D_ATTACK;
		}

		break;
	}
}

/* Start Envelope
 * Called when a voice is keyed on to set up the internal data to begin
 * envelope modification based on the values in ADSR/Gain. */
static INLINE void StartEnv(int32_t i)
{
	if ((mix[i].mFlg & (MFLG_OFF | MFLG_END)) || (mix[i].eMode & E_IDLE))
		mix[i].eDec = 0;

	if (APU.DSP[chs[i].o + APU_ADSR1] & 0x80)
		ChgAtt(i);
	else
		ChgGain(i);
}

static INLINE void UpdateEnv(int32_t i)
{
	if (mix[i].eMode & E_TYPE) /* Is the adjustment exponential? (mode 1, 9, or D) - E_EXP, E_SUST, E_DECAY */
	{
		if (mix[i].eVal > mix[i].eDest)
		{
			mix[i].eVal--;
			mix[i].eVal -= mix[i].eVal >> 8;

			if (mix[i].eVal >= mix[i].eDest)
				return;

			mix[i].eVal = mix[i].eDest;
		}
	}
	else if (mix[i].eMode & E_DIR) /* Linear increase (mode 2, 6, or A) - E_INC, E_BENT, E_ATT */
	{
		if (mix[i].eVal < mix[i].eDest)
		{
			mix[i].eVal += mix[i].eAdj;

			if (mix[i].eVal <= mix[i].eDest)
				return;

			mix[i].eVal = mix[i].eDest;
		}
	}
	else /* Linear decrease (mode 0 or 8) - E_DEC, E_REL */
	{
		if (mix[i].eVal > mix[i].eDest)
		{
			if (mix[i].eVal >= mix[i].eAdj)
				mix[i].eVal -= mix[i].eAdj;
			else
				mix[i].eVal = mix[i].eDest;

			if (mix[i].eVal > mix[i].eDest)
				return;
		}

		if (mix[i].eMode == E_REL) /* Is voice in release mode? */
		{
			mix[i].mFlg |= MFLG_OFF;
			mix[i].mFlg &= ~MFLG_KOFF;
		}
	}

	if (mix[i].eMode & E_ADSR) /* Is envelope in ADSR mode? E_REL, E_SUST, E_ATT, E_DECAY */
	{
		switch (mix[i].eMode) /* Change adjustment mode */
		{
			case E_ATT:
				if (mix[i].eVal >= mix[i].eDest)
					ChgDec(i);

				return;
			case E_DECAY:
				if (mix[i].eVal <= mix[i].eDest)
					ChgSus(i);

				return;
			case E_SUST:
			case E_REL:
				break;
		}
	}
	else if (mix[i].eMode & E_DEST) /* Is gain in bent line mode? No, it's constant */
	{
		if (mix[i].eDest == D_BENT)
		{
			mix[i].eAdj = A_BENT;
			mix[i].eDest = D_ATTACK;
			return;
		}
	}

	mix[i].eMode |= E_IDLE;
	mix[i].eVal = mix[i].eDest; /*clip eVal */
	mix[i].eDec = 0;
}

static INLINE void CalcEnv(int32_t i)
{
	uint32_t e;

	if (mix[i].eMode & E_IDLE)
		return;

	mix[i].eDec += mix[i].eRate;
	e = mix[i].eDec >> FIXED_POINT_SHIFT;
	mix[i].eDec &= FIXED_POINT_REMAINDER;

	for (; e; e--)
	{
		UpdateEnv(i);

		if (mix[i].eMode & E_IDLE)
			break;
	}
}

static INLINE void ChgSilence(int32_t ch)
{
	mix[ch].eMode = E_DIRECT;
	mix[ch].eRIdx = 0;
	mix[ch].eRate = rateTab[mix[ch].eRIdx];
	mix[ch].eAdj = A_EXP;
	mix[ch].eVal = mix[ch].eDest = D_MIN;
	mix[ch].mFlg |= MFLG_OFF;
	mix[ch].mFlg &= (MFLG_MUTE | MFLG_OFF);
}

static INLINE void ProcessSrc(int32_t i)
{
	/* Waveform Resizing */
	int8_t sc = (int8_t) ((mix[i].mDec += mix[i].mRate) >> FIXED_POINT_SHIFT); /* MAX is 16 in 8000Hz Pitch 0x3FFF */
	int8_t sIdx = (mix[i].sIdx + sc) & 0x1f;
	mix[i].mDec &= FIXED_POINT_REMAINDER;

	if ((mix[i].sIdx ^ sIdx) & 0x10) /* It needs next 16 samples? */
	{
		mix[i].sIdx = sIdx;
		UpdateSrc(i);
	}
	else
		mix[i].sIdx = sIdx;

	if (mix[i].mFlg & MFLG_END)
		return;

	sc >>= 4;

	if (sc > 0)
	{
		mix[i].sIdx ^= 0x10;
		UpdateSrc(i);
	}
}

void APUDSPIn(uint8_t address, uint8_t data) /* DSP Data Port */
{
	/* Writes to 80-FFh have no effect (reads are mirrored from lower mem) */
	if (address & 0x80)
		return;

	switch (address)
	{
	case APU_KON:
	case APU_KOFF:
		InitReg(address, data);
		break;
	case APU_FLG:
		RFlg((address & 0x70) >> 4, data);
		break;
	case APU_ENDX:
		REndX((address & 0x70) >> 4, data);
		break;
	default:
		if (data == APU.DSP[address])
			break;

		if(!(address & 0x08))
		{
			APU.DSP[address] = data;
			uint8_t i = ((address) & 0x70) >> 4;

			if(!(mix[i].mFlg & MFLG_OFF))
				(*dspRegs[address])(i, data);
		}
		else
			InitReg(address, data);
	}
}

/* Channel volume */
static void RVolL(int32_t i, uint8_t val)
{
	mix[i].mChnL = (int32_t) (int8_t) val;
}

static void RVolR(int32_t i, uint8_t val)
{
	mix[i].mChnR = (int32_t) (int8_t) val;
}

static void RPitch(int32_t i, uint8_t _2) /* Pitch */
{
	uint64_t r;
	(void) _2;
	mix[i].mOrgP = DSP_GET_PITCH(i);
	r = (uint64_t) mix[i].mOrgP * pitchAdj;
	mix[i].mOrgRate = (uint32_t) ((r >> FIXED_POINT_SHIFT) + ((r & FIXED_POINT_REMAINDER) ? 1 : 0));
}

/* Envelope */
static void RADSR1(int32_t i, uint8_t _2)
{
	(void) _2;

	if (mix[i].mFlg & MFLG_KOFF) /* MFLG_OFF was checked in InitReg() */
		return;

	if (APU.DSP[chs[i].o + APU_ADSR1] & 0x80)
		ChgADSR(i);
	else
		ChgGain(i);
}

static void RADSR2(int32_t i, uint8_t _2)
{
	(void) _2;

	if ((mix[i].mFlg & MFLG_KOFF) || !(APU.DSP[chs[i].o + APU_ADSR1] & 0x80)) /* MFLG_OFF was checked in InitReg() */
		return;

	ChgADSR(i);
}

static void RGain(int32_t i, uint8_t _2)
{
	(void) _2;

	if ((mix[i].mFlg & MFLG_KOFF) || (APU.DSP[chs[i].o + APU_ADSR1] & 0x80)) /* MFLG_OFF was checked in InitReg() */
		return;

	ChgGain(i);
}

/* Main volumes */
static void RMVolL(int32_t _1, uint8_t val)
{
	(void) _1;
	volMainL = ((int32_t) (int8_t) val * volAdj) >> FIXED_POINT_SHIFT;
}

static void RMVolR(int32_t _1, uint8_t val)
{
	(void) _1;
	volMainR = ((int32_t) (int8_t) val * volAdj) >> FIXED_POINT_SHIFT;
}

static void REVolL(int32_t _1, uint8_t val)
{
	(void) _1;
	volEchoL = ((int32_t) (int8_t) val * volAdj) >> FIXED_POINT_SHIFT;
}

static void REVolR(int32_t _1, uint8_t val)
{
	(void) _1;
	volEchoR = ((int32_t) (int8_t) val * volAdj) >> FIXED_POINT_SHIFT;
}

/* Echo settings */
static void REFB(int32_t _1, uint8_t val)
{
	(void) _1;
	echoFB = (int32_t) (int8_t) val;
}

static void REDl(int32_t _1, uint8_t val)
{
	(void) _1;
	val &= 0x0f;

	if (val == 0)
		echoDel = 2;
	else
		echoDel = ((uint32_t) (val << 4) * dspRate / 1000) << 1;
}

static void RFCI(int32_t i, uint8_t val)
{
	FilterTaps[i] = (int8_t) val;
}

/* Key On/Off */
static void RKOn(int32_t i, uint8_t val)
{
	if (val)
	{
		for (i = 0; i < 8; i++)
		{
			if (!(val & chs[i].m))
				continue;

			/* Set channel volume */
			(*dspRegs[chs[i].o + APU_VOL_LEFT])(i, APU.DSP[chs[i].o + APU_VOL_LEFT]);
			(*dspRegs[chs[i].o + APU_VOL_RIGHT])(i, APU.DSP[chs[i].o + APU_VOL_RIGHT]);

			/* Set pitch */
			RPitch(i, APU.DSP[chs[i].o + APU_P_LOW]);
			StartEnv(i);

			/* Start waveform decompression */
			mix[i].bStart = DSP_GET_SRC(i);
			mix[i].mFlg |= MFLG_SSRC;
			mix[i].mFlg &= ~(MFLG_KOFF | MFLG_OFF); /* Reset flags */

			/* Mark voice as being on internally */
			voiceKon |= chs[i].m;
		}
	}
}

static void RKOf(int32_t i, uint8_t val)
{
	val &= voiceKon; /* Only check voices that are currently playing */

	if (!val)
		return;

	for (i = 0; i < 8; i++)
	{
		if (!(val & chs[i].m))
			continue;

		mix[i].eRIdx = 0x1f; /* 1->0 8ms */
		mix[i].eRate = rateTab[mix[i].eRIdx];
		mix[i].eAdj = A_KOF;
		mix[i].eDest = D_MIN;
		mix[i].eMode = E_REL;
		mix[i].mFlg |= MFLG_KOFF; /* Flag voice as keying off */
		voiceKon &= ~chs[i].m;
	}
}

static void RFlg(int32_t _1, uint8_t val)
{
	(void) _1;
	disEcho = (disEcho & ~APU_ECHO_DISABLED) | (val & APU_ECHO_DISABLED); /* Disable echo */
	APU.DSP[APU_FLG] = val;
	SetNoiseHertz();
}

static void RESA(int32_t _1, uint8_t val)
{
	(void) _1;
	echoStart = (val * 64 * dspRate / SNES_SAMPLE_RATE) << 1;
}

static void REndX(int32_t _1, uint8_t _2)
{
	(void) _1;
	(void) _2;
	APU.DSP[APU_ENDX] = 0;
}

static void RNull(int32_t _1, uint8_t _2) /* Null register */
{
	(void) _1;
	(void) _2;
}

static INLINE void NoiseGen() /* Noise Generator - Generates white noise samples (into nSmp) */
{
	int32_t feedback;
	nDec += nRate;

	if (nDec < 0x7800)
		return;

	nDec -= 0x7800;
	feedback = (nSmp << 13) ^ (nSmp << 14);
	nSmp = (feedback & 0x4000) ^ (nSmp >> 1);
}

/* Pitch Modulation - Changes the pitch based on the output of the previous voice:
   P' = (P * (OUTX + 32768)) >> 15

   Pitch modulation in the SNES uses the full 16-bit sample value, not the 8-bit value in OUTX as
   previously believed. */
static INLINE void PitchMod(int32_t ch)
{
	uint64_t r;
	int32_t t = ((mix[ch - 1].mOut + 32768) * mix[ch].mOrgP) >> 15;

	if (t > 0x3FFF)
		t = 0x3FFF;
	else if (t < 0)
		t = 0;

	r = (uint64_t) t * pitchAdj;
	mix[ch].mRate = (uint32_t) ((r >> FIXED_POINT_SHIFT) + ((r & FIXED_POINT_REMAINDER) ? 1 : 0));
}

static INLINE int32_t GetCurSample(int32_t ch)
{
	int32_t mDec, cursample;

	if (mix[ch].sIdx < 0)
		return 0;

	/* Gaussian Interpolation */
	mDec = (mix[ch].mDec >> 8) << 2;
	cursample = (int32_t) (int16_t) (
	    (((int32_t) mix[ch].sBuf[(mix[ch].sIdx - 3) & 0x1f] * gaussTab[mDec + 0]) >> 16) + /* d0 */
	    (((int32_t) mix[ch].sBuf[(mix[ch].sIdx - 2) & 0x1f] * gaussTab[mDec + 1]) >> 16) + /* d1 */
	    (((int32_t) mix[ch].sBuf[(mix[ch].sIdx - 1) & 0x1f] * gaussTab[mDec + 2]) >> 16) + /* d2 */
	    (((int32_t) mix[ch].sBuf[mix[ch].sIdx] * gaussTab[mDec + 3]) >> 16)); /* d3 */
	return cursample << 1;
}

static INLINE int32_t ProcessSample(int32_t ch)
{
	int32_t eVal;

	if (!(mix[ch].mFlg & MFLG_END)) /* Is there reproducing sound data? */
	{
		if (APU.DSP[APU_PMON] & ~APU.DSP[APU_NON] & ~chs[0].m & chs[ch].m) /* Pitch Modulation */
			PitchMod(ch);
		else
			mix[ch].mRate = mix[ch].mOrgRate;

		/* Waveform Resizing */
		ProcessSrc(ch);
		eVal = mix[ch].eVal;

		if (eVal > D_ATTACK)
			eVal = D_ATTACK;
		else if (eVal < D_MIN)
			eVal = D_MIN;

		if (APU.DSP[APU_NON] & chs[ch].m)
		{
			mix[ch].mOut = (((int32_t) ((int16_t) (nSmp << 1)) * eVal) >> (E_SHIFT + 7)) & ~1;
			return mix[ch].mOut;
		}
		else
		{
			mix[ch].mOut = ((GetCurSample(ch) * eVal) >> (E_SHIFT + 7)) & ~1;
			return ((GetCurSample(ch) * eVal) >> (E_SHIFT + 7)) & ~1;
		}
	}
	else /* Note this, the noise hears only the length of the sound source data. */
		return mix[ch].mOut = 0;
}

/* Finite Impulse Response Echo Filter - Filters the echo using an eight tap FIR filter:
 *         7
 *        ---
 *    x = \   c  * s
 *        /    n    n
 *        ---
 *        n=0
 *
 *    x = output sample
 *    c = filter coefficient (-.7)
 *    s = unfiltered sample
 *    n = 0 is the oldest sample and 7 is the most recent
 *
 * FIR filters are based on the sample rate. This was fine in the SNES, because the sample rate was
 * always 32kHz, but in the case of an emulator the sample rate can change. So measures have to be
 * taken to ensure the filter will have the same effect, regardless of the output sample rate.
 * To overcome this problem, I figured each tap of the filter is applied every 31250ns. So the
 * solution is to calculate when 31250ns have gone by, and use the sample at that point. Of course
 * this method really only works if the output rate is a multiple of 32k. In order to get accurate
 * results, some sort of interpolation method needs to be introduced. I went the cheap route and used
 * linear interpolation. */
static INLINE void FIRFilter(int32_t* l, int32_t* r)
{
	/* Reset decimal overflow, so filtering is consistent */
	uint8_t fi = firCur;
	int32_t i;
	*l = *r = 0;

	for (i = 0; i < 8; i++)
	{
		*l += (Loop[fi + 0] * FilterTaps[i]) >> 6;
		*r += (Loop[fi + 1] * FilterTaps[i]) >> 6;
		fi = (fi - 2) & (FIRBUF - 2);
	}
}

static INLINE void ECHOFilter(int32_t* l, int32_t* r, int32_t ll, int32_t rr)
{
	Loop[firCur + 0] = (int16_t) DSP_GET_WORD((echoStart + echoCur + 0) << 1) >> 1;
	Loop[firCur + 1] = (int16_t) DSP_GET_WORD((echoStart + echoCur + 1) << 1) >> 1;

	/* Filter echo */
	FIRFilter(l, r);
	firCur = (firCur + 2) & (FIRBUF - 2);

	if (!(APU.DSP[APU_FLG] & APU_ECHO_DISABLED)) /* Add feedback */
	{
		DSP_SET_WORD((echoStart + echoCur + 0) << 1, INT16_CLAMP(ll + ((*l * echoFB) >> 7)) & ~1);
		DSP_SET_WORD((echoStart + echoCur + 1) << 1, INT16_CLAMP(rr + ((*r * echoFB) >> 7)) & ~1);
	}

	echoCur = (echoCur + 2) % echoDel;
}

void MixSamples(int16_t* pBuf, int32_t num) /* Emulate DSP - Emulates the DSP of the SNES */
{
	int32_t ch, cnt, eVal;

	for (cnt = 0; cnt < num; cnt++, pBuf += DSP_SIZE)
	{
		/* Erase current samples */
		int32_t MixSampleL = 0, MixSampleR = 0;
		int32_t EchoSampleL = 0, EchoSampleR = 0;
		int32_t l, r;
		NoiseGen(); /* Generate Noise */

		for (ch = 0; ch < 8; ch++)
		{
			if (APU.DSP[APU_FLG] & APU_SOFT_RESET)
			{
				if(!(mix[ch].mFlg & MFLG_OFF))
					ChgSilence(ch);
			}

			if ((mix[ch].mFlg & MFLG_SSRC) || mix[ch].bStart != mix[ch].bMixStart)
			{
				mix[ch].mFlg &= ~MFLG_SSRC;
				StartSrc(ch);
				mix[ch].mFlg &= ~MFLG_END;
				mix[ch].mDec = 0;
			}

			if (!(mix[ch].mFlg & MFLG_OFF)) /* Is the current voice active? */
			{
				int32_t cursample = ProcessSample(ch);

				if (cursample != 0 && !(mix[ch].mFlg & MFLG_MUTE)) /* Mixing */
				{
					MixSampleL += (cursample * mix[ch].mChnL) >> 7; /* Add to master samples */
					MixSampleR += (cursample * mix[ch].mChnR) >> 7;

					if (APU.DSP[APU_EON] & chs[ch].m) /* Is echo on? */
					{
						EchoSampleL += (cursample * mix[ch].mChnL) >> 7;
						EchoSampleR += (cursample * mix[ch].mChnR) >> 7;
					}
				}

				CalcEnv(ch); /* Envelope Calculation */
			}
			else
				mix[ch].mOut = 0;

			eVal = mix[ch].eVal >> E_SHIFT;

			if (eVal > 0x7f)
				eVal = 0x7f;
			else if (eVal < 0)
				eVal = 0;

			APU.DSP[chs[ch].o + APU_ENVX] = eVal;
			APU.DSP[chs[ch].o + APU_OUTX] = mix[ch].mOut >> 8;
		}

		ECHOFilter(&l, &r, EchoSampleL, EchoSampleR);

		if (!(APU.DSP[APU_FLG] & APU_MUTE)) /* Is the DSP not muted? */
		{
			/* Multiply samples by main volume */
			MixSampleL = (MixSampleL * volMainL) >> 7;
			MixSampleR = (MixSampleR * volMainR) >> 7;

			if (!(disEcho & DSP_NOECHO))
			{
				MixSampleL += (l * volEchoL) >> 7;
				MixSampleR += (r * volEchoR) >> 7;
			}

			pBuf[0] = INT16_CLAMP(MixSampleL);
			pBuf[1] = INT16_CLAMP(MixSampleR);
		}
		else /* Clear sound buffer */
			pBuf[0] = pBuf[1] = 0;
	}
}

/* Decompress Sound Source - Decompresses a 9-byte bit-rate reduced block into 16 16-bit samples
   In:
      blk_hdr     = Block header
      xsample_blk = Sample Block
      output_buf  = Output buffer
      smp_1       = Last sample of previous block
      smp_2       = Next to last sample
   Out:
      xsample_blk = Next Block
      smp_1       = Last sample
      smp_2       = Next to last sample */
static INLINE int32_t UnpckSrcFilter(int32_t f, int32_t p1, int32_t p2)
{
	switch (f)
	{
		case 1: /* Method1 - [Delta]+[Smp-1](15/16) */
			return ((p1 >> 1) + ((-p1) >> 5));
		case 2: /* Method2 - [Delta]+[Smp-1](61/32)-[Smp-2](15/16) */
			return (p1 - (p2 >> 1) + (p2 >> 5) + ((p1 * -3) >> 6));
		case 3: /* Method3 - [Delta]+[Smp-1](115/64)-[Smp-2](13/16) */
			return (p1 - (p2 >> 1) + ((p1 * -13) >> 7) + (((p2 >> 1) * 3) >> 4));
		default: /* Method0 - [Smp] */
			return 0;
	}
}

static void UnpckSrc(uint8_t blk_hdr, uint16_t* xsample_blk, int16_t* output_buf, int32_t* smp_1, int32_t* smp_2)
{
	int32_t i;
	uint8_t* sample_blk = DSP_GET_SRC_P(*xsample_blk) + 1;
	const int* BRR_row = &brrTab[(blk_hdr & 0xf0)];
	int32_t f = (blk_hdr & 0x0c) >> 2;
	*xsample_blk += 9;

	for (i = 0; i < 8; i++)
	{
		*smp_2 = BRR_row[sample_blk[0] >> 4] + UnpckSrcFilter(f, *smp_1, *smp_2);
		*smp_2 = (int16_t) (INT16_CLAMP(*smp_2) << 1);
		output_buf[0] = *smp_2;
		*smp_1 = BRR_row[sample_blk[0] & 0x0f] + UnpckSrcFilter(f, *smp_2, *smp_1);
		*smp_1 = (int16_t) (INT16_CLAMP(*smp_1) << 1);
		output_buf[1] = *smp_1;
		sample_blk++;
		output_buf += 2;
	}
}
